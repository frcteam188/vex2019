#pragma config(Motor,  port2,           frontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           midLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           frontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           midRight,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           backRight,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*

*Plz edit after changes*
Date Created: Nov 22 2019
Last Edited by: Zayeed Ghori
Date Last Edited: Nov 22 2019

*/

void tankDrive(){//fix this
	// Tank
	// These functions control motor values (clockwise +, counter -) based on joystick input (2 and 3)
while(true){
	motor[frontLeft] = vexRT[Ch3];
	motor[frontRight] = -vexRT[Ch2];
	motor[backLeft] = vexRT[Ch3];
	motor[backRight] = -vexRT[Ch2];
	}
}

void arcadeDrive(){
	// Arcade
	// These functions control motor values (clockwise +, counter -) based on joystick input (1 and 3)
	motor[frontLeft] = vexRT[Ch3] + vexRT[Ch1];
	motor[midLeft] = -vexRT[Ch3] - vexRT[Ch1];
	motor[backLeft] = vexRT[Ch3] + vexRT[Ch1];
	motor[frontRight] = vexRT[Ch3] - vexRT[Ch1];
	motor[midRight] = -vexRT[Ch3] + vexRT[Ch1];
	motor[backRight] = vexRT[Ch3] - vexRT[Ch1];
}

// This function is the test function for the driver remote to have ghost power and prevent the arms from falling due to grvity
void ghostPower(int left, int right){
	while (!vexRT[Btn5D] && !vexRT[Btn5U]) {
		motor[armLeft] = left;
		motor[armRight] = right;
	}
}

// This function allows the operator controller to control the movement of the arms through joystick axis 3
void armControl(){
	//Test
	if (vexRT[Btn5U] && !vexRT[Btn5D]){
		motor[armLeft] = -127;
	  motor[armRight] = 127;
		ghostPower(-20, 20);
	}
	else if (!vexRT[Btn5U] && vexRT[Btn5D]){
		motor[armLeft] = 30;
	  motor[armRight] = -30;
		ghostPower(-20, 20);
	}
	else {
		motor[armLeft] = 0;
	  motor[armRight] = 0;
	}

	 Operator control
	motor[armLeft] = -vexRT[Ch3Xmtr2];
	motor[armRight] = vexRT[Ch3Xmtr2];
}

task main()
{
	// Teleop
	while(true) {
		arcadeDrive();
	}
}
