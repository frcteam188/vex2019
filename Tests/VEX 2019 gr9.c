#pragma config(Motor,  port2,           frontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           frontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           backRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           armLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armRight,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           intakeRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           intakeLeft,   tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
/*

*Plz edit after changes*
Date Created: Oct 8 2019
Last Edited by: Zayeed Ghori
Date Last Edited: Oct 25 2019

*/

void tankDrive(){//fix this
	// Tank
	// These functions control motor values (clockwise +, counter -) based on joystick input (2 and 3)
	motor[frontLeft] = -vexRT[Ch3];
	motor[backLeft] = -vexRT[Ch3];
	motor[frontRight] = -vexRT[Ch2];
	motor[backRight] = -vexRT[Ch2];
}

void arcadeDrive(){
	// Arcade
	// These functions control motor values (clockwise +, counter -) based on joystick input (1 and 3)
	motor[frontLeft] = vexRT[Ch3] + vexRT[Ch1];
	motor[backLeft] = vexRT[Ch3] + vexRT[Ch1];
	motor[frontRight] = -vexRT[Ch3] + vexRT[Ch1];
	motor[backRight] = -vexRT[Ch3] + vexRT[Ch1];
}

// This function is the test function for the driver remote to have ghost power and prevent the arms from falling due to grvity
void ghostPower(int left, int right) {
	while (!vexRT[Btn5D] && !vexRT[Btn5U]) {
		motor[armLeft] = left;
		motor[armRight] = right;
	}
}
void armUp() {
		motor[armLeft] = -127;
	  motor[armRight] = 127;
}

void armControl(){
	// TEST
	//if (vexRT[Btn5U] && !vexRT[Btn5D]){
	//	motor[armLeft] = 127;
	//  motor[armRight] = -127;
	//  ghostPower(20, -20);
	//}
	//else if (!vexRT[Btn5U] && vexRT[Btn5D]){
	//	motor[armLeft] = -127;
	//  motor[armRight] = 127;
	//  ghostPower(20, -20);
	//}
	//else {
	//	motor[armLeft] = 0;
	//  motor[armRight] = 0;
	//}

	motor[armLeft] = vexRT[Ch3Xmtr2];
	motor[armRight] = -vexRT[Ch3Xmtr2];
}

void intakeControl(){
	if (vexRT[Btn6U] && !vexRT[Btn6D]){
		motor[intakeLeft] = 127;
	  motor[intakeRight] = -127;
	}
	else if (!vexRT[Btn6U] && vexRT[Btn6D]){
		motor[intakeLeft] = -127;
	  motor[intakeRight] = 127;
	}
	else {
		motor[intakeLeft] = 0;
	  motor[intakeRight] = 0;
	}

	// Operator control
	motor[intakeLeft] = -vexRT[Ch2Xmtr2];
	motor[intakeRight] = vexRT[Ch2Xmtr2];
}

task main()
{
	// Teleop
	while(true) {
		arcadeDrive();
		armControl();
		intakeControl();
	}
}
