#pragma config(Motor,  port1,           frontLeft,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           armCloseLeft,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           armFarRight,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           backRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           backLeft,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           armFarLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           armCloseRight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           base,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          frontRight,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void drive(int left,int right) {
	motor[frontLeft] = -left;
	motor[backLeft] = -left;
	motor[frontRight] = -right;
	motor[backRight] = -right;
}

void move_arm(int value) {
	motor[armFarLeft] = value;
	motor[armCloseLeft] = value;
	motor[armFarRight] = value;
	motor[armCloseRight] = value;
}

void mobile_base(int value) {
	motor[base] = value;
}

void move_claw(int value) {
	motor[claw] = value;
}

void wait(float value) {
	wait1Msec(value * 1000);
}

task main()
{

	// AUTONOMOUS
	move_claw(50); // applies constant pressure on cone
	clearTimer(T1);

	while (time1[T1] < 2000) {
		if (time1[T1] < 1200) {
			move_arm(127); //lifts arm
		}
		else {
			move_arm(0); //stops arm
		}

		if (time1[T1] > 600) {
			mobile_base(127); // lifts mobile base
		}

		if (time1[T1] > 1150) {
			drive (127,127); // moves forward
		}
	}

	wait(1.0);
	mobile_base(-127); // picks up mobile base
	wait(0.8);
	move_arm(127);
	wait(0.3);
	drive(0,0);
	wait(0.4);
	move_arm(0);
	wait(1.2);

	move_arm(-50); //places cone on mobile base


	wait(0.8);

	drive(-40,-127); //drives backwards
	wait(1.5);
	drive(0,-127);

	wait(2.5);

	drive(127,-127);


	mobile_base(0);

	// TURNING

	wait(1.65);
	move_arm(0);
	/*
	drive(127,-127); //turns a little to avoid wall
	wait(0.3);

	drive(-127,-127); // reveses a little
	wait(0.8);

	drive(127, -127); //turns more
	wait(0.6);

	drive(-127,-127); // reveses to center
	wait(0.8);

	drive(127, -127); //turns towards speed bumps
	wait(1.2);
	*/
	drive(15,127); //curve

	move_claw(-127); //releases claw
	wait(2.6);
	drive(-127,127);
	wait(0.2);

	drive(127,127); //charges over bumps
	wait(2.5);
	drive(0,0); //stops

	wait(0.5);
	move_arm(127); // raises arm
	wait(0.6);

	mobile_base(127); //extends mobile base
	wait(0.6);

	move_arm(0);
	wait(0.5);

	mobile_base(0);

	drive(-127,-127); //pulls out leaving mobile base
	wait(1);


	// TELEOP
	motor[claw] = 5;
	bool clawClosed = true;
	while(true){

			motor[backLeft] = (-vexRT[Ch3] - vexRT[Ch1]);
			motor[frontLeft] = (-vexRT[Ch3] - vexRT[Ch1]);
			motor[backRight] = (-vexRT[Ch3] + vexRT[Ch1]);
			motor[frontRight] = (-vexRT[Ch3] + vexRT[Ch1]);

			motor[base] = (vexRT[Ch2Xmtr2]); // left joystick for mobile base

			motor[armFarLeft] = (vexRT[Ch3Xmtr2]); // right joystick for arm
			motor[armCloseLeft] = (vexRT[Ch3Xmtr2]);
			motor[armFarRight] = (vexRT[Ch3Xmtr2]);
			motor[armCloseRight] = (vexRT[Ch3Xmtr2]);

			int closedButton = vexRT[Btn6DXmtr2], openButton = vexRT[Btn6UXmtr2];
			if (openButton == 1){
				motor[claw] = -127;
				// open claw (run claw motors)
				clawClosed = false;
			}
			else if (closedButton == 1){
				// close claw
				motor[claw] = 127;

				clawClosed = true;
			}

			else if (clawClosed == true){
				motor[claw] = 15;
			}

			else {
				motor[claw] = 0;

			}
	}
}
