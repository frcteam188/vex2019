#pragma config(Sensor, dgtl1,  stackPos,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  armPos,         sensorQuadEncoder)
#pragma config(Motor,  port1,           armRight,      tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           frontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           midRight,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           backRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           frontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           midLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           stackPusher,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          armLeft,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*

*Plz edit after changes*
Date Created: Oct 10 2019
Last Edited by: Zayeed Ghori
Date Last Edited: Nov 27 2019

*/

// This incomplete function is suposed to take a bunch of motor names and reset their values to 0
//void resetMotors(int motor, ...){

//  va_list ap;
//  int i;

//  va_start (ap, count);         /* Initialize the argument list. */

//  for (i = 0; i < count; i++)
//    va_arg (ap, int) = 0;    /* Get the next argument value. */

//  va_end (ap);
//}

void tankDrive(){
	// Tank
	// These functions control motor values (clockwise +, counter -) based on joystick input (2 and 3)
	motor[frontLeft] = vexRT[Ch3];
	motor[frontRight] = -vexRT[Ch2];
	motor[backLeft] = vexRT[Ch3];
	motor[backRight] = -vexRT[Ch2];
}

void arcadeDrive(){
	// Arcade
	// These functions control motor values (clockwise +, counter -) based on joystick input (1 and 3)

	// Padding for insignificant input from the joystick
	if ((vexRT[Ch3] <= 5 && vexRT[Ch3] >= -5) && (vexRT[Ch1] <= 5 && vexRT[Ch1] >= -5)){
		motor[frontLeft] = 0;
		motor[midLeft] = 0;
		motor[backLeft] = 0;
		motor[frontRight] = 0;
		motor[midRight] = 0;
		motor[backRight] = 0;
	}

	// Regular joystick input
	else{
		motor[frontLeft] = vexRT[Ch3] + vexRT[Ch1];
		motor[midLeft] = -vexRT[Ch3] - vexRT[Ch1];
		motor[backLeft] = -vexRT[Ch3] - vexRT[Ch1];
		motor[frontRight] = vexRT[Ch3] - vexRT[Ch1];
		motor[midRight] = vexRT[Ch3] - vexRT[Ch1];
		motor[backRight] = -vexRT[Ch3] + vexRT[Ch1];
	}
}

// This function is the test function for the driver remote to have ghost power and prevent the arms from falling due to gravity
void ghostPower(int left, int right){
	while (!vexRT[Btn5D] && !vexRT[Btn5U]) {
		motor[armLeft] = left;
		motor[armRight] = right;
	}
}

// This function moves the arms of the robot based on Ch3 value on the Op controller
void armControl(){
	//TEST
	//if (vexRT[Btn5U] && !vexRT[Btn5D]){
	//	motor[armLeft] = -127;
	//  motor[armRight] = 127;
	//}
	//else if (!vexRT[Btn5U] && vexRT[Btn5D]){
	//	motor[armLeft] = 127;
	//  motor[armRight] = -127;
	//}
	//else{
	//	motor[armLeft] = 0;
	//	motor[armRight] = 0;
	//}

	motor[armLeft] = -vexRT[Ch3Xmtr2];
	motor[armRight] = vexRT[Ch3Xmtr2];
}

// This function brings the arms into the short lock position
void armLockLow(){
	motor[armLeft] = -127;
	motor[armRight]= 127;
}

// This function brings the arm into the high lock position
void armLockHigh(){
	motor[armLeft] = -127;
	motor[armRight]= 127;
}

// This function controls the intake motors based on 6D and 6U button values on the driver controller
void intakeSucc(){
	// Padding/Ghost power

	if (vexRT[Ch2Xmtr2] <= 5 && vexRT[Ch2Xmtr2] >= -5){

		motor[intake] = 0;

	}

	else{
		motor[intake] = -vexRT[Ch2Xmtr2];
	}
}

int incrementButtonCount(bool buttonPressed, int numOfPresses){
	if (buttonPressed){
		numOfPresses++;
	}

	int mode = numOfPresses % 2;
	return mode;
}

void stackControl(){
	// Push
	//int mode = incrementButtonCount(vexRT[Btn7DXmtr2], buttonPushes);
	if(vexRT[Btn7DXmtr2]){
		clearTimer(timer1);
		while (SensorValue[stackPos] < 60){
			motor[stackPusher] = 50;
			motor[intake] = 20;
		}
	}

	// Pull back
	else if(vexRT[Btn7LXmtr2]){
		clearTimer(timer1);
		while(SensorValue[stackPos] > 2){
			motor[stackPusher] = -50;
		}
	}
			//this was made by shiv. It is not clean but they needed it fast so i did it in the main. Change if you need to make it look nicer
		while(vexRT[Btn6U]) {
			motor[stackPusher] = 127;
		}
	// Resets the motor values to 0 if none of the if statements run
	else{
		motor[stackPusher] = 0;
	}
}

//int stackButtonPushes = 0;

task main()
{
	// Teleop
	int intakeMode = 0;
	int intakeButtonPushes = 0;
	SensorValue[stackPos] = 0;
	SensorValue[armPos] = 0;
	while(true) {
		//if (vexRT[Btn8LXmtr2]){
		//	intakeButtonPushes++;
		//}
		//intakeMode = intakeButtonPushes % 2;

		arcadeDrive();
		armControl();
		intakeSucc();
		stackControl();
		writeDebugStreamLine("%d", SensorValue[stackPos]);
		writeDebugStreamLine("%d", SensorValue[armPos]);
	}
}
